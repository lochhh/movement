
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/smooth.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_smooth.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_smooth.py:

Smooth pose tracks
=====================

Smooth pose tracks using the median and Savitzky-Golay filters.

.. GENERATED FROM PYTHON SOURCE LINES 8-10

Imports
-------

.. GENERATED FROM PYTHON SOURCE LINES 10-21

.. code-block:: Python


    from matplotlib import pyplot as plt
    from scipy.signal import welch

    from movement import sample_data
    from movement.filtering import (
        interpolate_over_time,
        median_filter,
        savgol_filter,
    )








.. GENERATED FROM PYTHON SOURCE LINES 22-28

Load a sample dataset
---------------------
Let's load a sample dataset and print it to inspect its contents.
Note that if you are running this notebook interactively, you can simply
type the variable name (here ``ds_wasp``) in a cell to get an interactive
display of the dataset's contents.

.. GENERATED FROM PYTHON SOURCE LINES 28-32

.. code-block:: Python


    ds_wasp = sample_data.fetch_dataset("DLC_single-wasp.predictions.h5")
    print(ds_wasp)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.Dataset> Size: 61kB
    Dimensions:      (time: 1085, individuals: 1, keypoints: 2, space: 2)
    Coordinates:
      * time         (time) float64 9kB 0.0 0.025 0.05 0.075 ... 27.05 27.07 27.1
      * individuals  (individuals) <U12 48B 'individual_0'
      * keypoints    (keypoints) <U7 56B 'head' 'stinger'
      * space        (space) <U1 8B 'x' 'y'
    Data variables:
        position     (time, individuals, keypoints, space) float64 35kB 1.086e+03...
        confidence   (time, individuals, keypoints) float64 17kB 0.05305 ... 0.0
    Attributes:
        fps:              40.0
        time_unit:        seconds
        source_software:  DeepLabCut
        source_file:      /home/runner/.movement/data/poses/DLC_single-wasp.predi...
        frame_path:       /home/runner/.movement/data/frames/single-wasp_frame-10...
        video_path:       None




.. GENERATED FROM PYTHON SOURCE LINES 33-36

We see that the dataset contains a single individual (a wasp) with two
keypoints tracked in 2D space. The video was recorded at 40 fps and lasts for
~27 seconds.

.. GENERATED FROM PYTHON SOURCE LINES 38-46

Define a plotting function
--------------------------
Let's define a plotting function to help us visualise the effects smoothing
both in the time and frequency domains.
The function takes as inputs two datasets containing raw and smooth data
respectively, and plots the position time series and power spectral density
(PSD) for a given individual and keypoint. The function also allows you to
specify the spatial coordinate (``x`` or ``y``) and a time range to focus on.

.. GENERATED FROM PYTHON SOURCE LINES 46-111

.. code-block:: Python



    def plot_raw_and_smooth_timeseries_and_psd(
        ds_raw,
        ds_smooth,
        individual="individual_0",
        keypoint="stinger",
        space="x",
        time_range=None,
    ):
        # If no time range is specified, plot the entire time series
        if time_range is None:
            time_range = slice(0, ds_raw.time[-1])

        selection = {
            "time": time_range,
            "individuals": individual,
            "keypoints": keypoint,
            "space": space,
        }

        fig, ax = plt.subplots(2, 1, figsize=(10, 6))

        for ds, color, label in zip(
            [ds_raw, ds_smooth], ["k", "r"], ["raw", "smooth"], strict=False
        ):
            # plot position time series
            pos = ds.position.sel(**selection)
            ax[0].plot(
                pos.time,
                pos,
                color=color,
                lw=2,
                alpha=0.7,
                label=f"{label} {space}",
            )

            # generate interpolated dataset to avoid NaNs in the PSD calculation
            ds_interp = interpolate_over_time(ds, max_gap=None, print_report=False)
            pos_interp = ds_interp.position.sel(**selection)
            # compute and plot the PSD
            freq, psd = welch(pos_interp, fs=ds.fps, nperseg=256)
            ax[1].semilogy(
                freq,
                psd,
                color=color,
                lw=2,
                alpha=0.7,
                label=f"{label} {space}",
            )

        ax[0].set_ylabel(f"{space} position (px)")
        ax[0].set_xlabel("Time (s)")
        ax[0].set_title("Time Domain")
        ax[0].legend()

        ax[1].set_ylabel("PSD (px$^2$/Hz)")
        ax[1].set_xlabel("Frequency (Hz)")
        ax[1].set_title("Frequency Domain")
        ax[1].legend()

        plt.tight_layout()
        fig.show()









.. GENERATED FROM PYTHON SOURCE LINES 112-118

Smoothing with a median filter
------------------------------
Here we use the :py:func:`movement.filtering.median_filter` function to
apply a rolling window median filter to the wasp dataset.
The ``window_length`` parameter is defined in seconds (according to the
``time_unit`` dataset attribute).

.. GENERATED FROM PYTHON SOURCE LINES 118-121

.. code-block:: Python


    ds_wasp_medfilt = median_filter(ds_wasp, window_length=0.1)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    head: 0/1085 (0.0%)
                    stinger: 0/1085 (0.0%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    head: 0/1085 (0.0%)
                    stinger: 0/1085 (0.0%)




.. GENERATED FROM PYTHON SOURCE LINES 122-125

We see from the printed report that the dataset has no missing values
neither before nor after smoothing. Let's visualise the effects of the
median filter in the time and frequency domains.

.. GENERATED FROM PYTHON SOURCE LINES 125-130

.. code-block:: Python


    plot_raw_and_smooth_timeseries_and_psd(
        ds_wasp, ds_wasp_medfilt, keypoint="stinger"
    )




.. image-sg:: /examples/images/sphx_glr_smooth_001.png
   :alt: Time Domain, Frequency Domain
   :srcset: /examples/images/sphx_glr_smooth_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 131-141

We see that the median filter has removed the "spikes" present around the
14 second mark in the raw data. However, it has not dealt the big shift
occurring during the final second. In the frequency domain, we can see that
the filter has reduced the power in the high-frequency components, without
affecting the low frequency components.

This illustrates what the median filter is good at: removing brief "spikes"
(e.g. a keypoint abruptly jumping to a different location for a frame or two)
and high-frequency "jitter" (often present due to pose estimation
working on a per-frame basis).

.. GENERATED FROM PYTHON SOURCE LINES 143-149

Choosing parameters for the median filter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
You can control the behaviour of :py:func:`movement.filtering.median_filter`
via two parameters: ``window_length`` and ``min_periods``.
To better understand the effect of these parameters, let's use a
dataset that contains missing values.

.. GENERATED FROM PYTHON SOURCE LINES 149-153

.. code-block:: Python


    ds_mouse = sample_data.fetch_dataset("SLEAP_single-mouse_EPM.analysis.h5")
    print(ds_mouse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <xarray.Dataset> Size: 1MB
    Dimensions:      (time: 18485, individuals: 1, keypoints: 6, space: 2)
    Coordinates:
      * time         (time) float64 148kB 0.0 0.03333 0.06667 ... 616.1 616.1 616.1
      * individuals  (individuals) <U12 48B 'individual_0'
      * keypoints    (keypoints) <U9 216B 'snout' 'left_ear' ... 'tail_end'
      * space        (space) <U1 8B 'x' 'y'
    Data variables:
        position     (time, individuals, keypoints, space) float32 887kB nan ... ...
        confidence   (time, individuals, keypoints) float32 444kB nan nan ... 0.7607
    Attributes:
        fps:              30.0
        time_unit:        seconds
        source_software:  SLEAP
        source_file:      /home/runner/.movement/data/poses/SLEAP_single-mouse_EP...
        frame_path:       /home/runner/.movement/data/frames/single-mouse_EPM_fra...
        video_path:       /home/runner/.movement/data/videos/single-mouse_EPM_vid...




.. GENERATED FROM PYTHON SOURCE LINES 154-159

The dataset contains a single mouse with six keypoints tracked in
2D space. The video was recorded at 30 fps and lasts for ~616 seconds. We can
see that there are some missing values, indicated as "nan" in the
printed dataset. Let's apply the median filter to this dataset, with
the ``window_length`` set to 0.1 seconds.

.. GENERATED FROM PYTHON SOURCE LINES 159-162

.. code-block:: Python


    ds_mouse_medfilt = median_filter(ds_mouse, window_length=0.1)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 4494/18485 (24.3%)
                    left_ear: 513/18485 (2.8%)
                    right_ear: 533/18485 (2.9%)
                    centre: 490/18485 (2.7%)
                    tail_base: 704/18485 (3.8%)
                    tail_end: 2496/18485 (13.5%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    snout: 5106/18485 (27.6%)
                    left_ear: 678/18485 (3.7%)
                    right_ear: 695/18485 (3.8%)
                    centre: 640/18485 (3.5%)
                    tail_base: 913/18485 (4.9%)
                    tail_end: 3103/18485 (16.8%)




.. GENERATED FROM PYTHON SOURCE LINES 163-174

The report informs us that the raw data contains NaN values, most of which
occur at the ``snout`` and ``tail_end`` keypoints. After filtering, the
number of NaNs has increased. This is because the default behaviour of the
median filter is to propagate NaN values, i.e. if any value in the rolling
window is NaN, the output will also be NaN.

To modify this behaviour, you can set the value of the ``min_periods``
parameter to an integer value. This parameter determines the minimum number
of non-NaN values required in the window for the output to be non-NaN.
For example, setting ``min_periods=2`` means that two non-NaN values in the
window are sufficient for the median to be calculated. Let's try this.

.. GENERATED FROM PYTHON SOURCE LINES 174-177

.. code-block:: Python


    ds_mouse_medfilt = median_filter(ds_mouse, window_length=0.1, min_periods=2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 4494/18485 (24.3%)
                    left_ear: 513/18485 (2.8%)
                    right_ear: 533/18485 (2.9%)
                    centre: 490/18485 (2.7%)
                    tail_base: 704/18485 (3.8%)
                    tail_end: 2496/18485 (13.5%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    snout: 4455/18485 (24.1%)
                    left_ear: 487/18485 (2.6%)
                    right_ear: 507/18485 (2.7%)
                    centre: 465/18485 (2.5%)
                    tail_base: 673/18485 (3.6%)
                    tail_end: 2428/18485 (13.1%)




.. GENERATED FROM PYTHON SOURCE LINES 178-184

We see that this time the number of NaN values has decreased
across all keypoints.
Let's visualise the effects of the median filter in the time and frequency
domains. Here we focus on the first 80 seconds for the ``snout`` keypoint.
You can adjust the ``keypoint`` and ``time_range`` arguments to explore other
parts of the data.

.. GENERATED FROM PYTHON SOURCE LINES 184-189

.. code-block:: Python


    plot_raw_and_smooth_timeseries_and_psd(
        ds_mouse, ds_mouse_medfilt, keypoint="snout", time_range=slice(0, 80)
    )




.. image-sg:: /examples/images/sphx_glr_smooth_002.png
   :alt: Time Domain, Frequency Domain
   :srcset: /examples/images/sphx_glr_smooth_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 190-194

The smoothing once again reduces the power of high-frequency components, but
the resulting time series stays quite close to the raw data.

What happens if we increase the ``window_length`` to 2 seconds?

.. GENERATED FROM PYTHON SOURCE LINES 194-197

.. code-block:: Python


    ds_mouse_medfilt = median_filter(ds_mouse, window_length=2, min_periods=2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 4494/18485 (24.3%)
                    left_ear: 513/18485 (2.8%)
                    right_ear: 533/18485 (2.9%)
                    centre: 490/18485 (2.7%)
                    tail_base: 704/18485 (3.8%)
                    tail_end: 2496/18485 (13.5%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    snout: 795/18485 (4.3%)
                    left_ear: 80/18485 (0.4%)
                    right_ear: 80/18485 (0.4%)
                    centre: 80/18485 (0.4%)
                    tail_base: 80/18485 (0.4%)
                    tail_end: 239/18485 (1.3%)




.. GENERATED FROM PYTHON SOURCE LINES 198-202

The number of NaN values has decreased even further. That's because the
chance of finding at least 2 valid values within a 2 second window is
quite high. Let's plot the results for the same keypoint and time range
as before.

.. GENERATED FROM PYTHON SOURCE LINES 202-206

.. code-block:: Python


    plot_raw_and_smooth_timeseries_and_psd(
        ds_mouse, ds_mouse_medfilt, keypoint="snout", time_range=slice(0, 80)
    )



.. image-sg:: /examples/images/sphx_glr_smooth_003.png
   :alt: Time Domain, Frequency Domain
   :srcset: /examples/images/sphx_glr_smooth_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 207-215

We see that the filtered time series is much smoother and it has even
"bridged" over some small gaps. That said, it often deviates from the raw
data, in ways that may not be desirable, depending on the application.
That means that our choice of ``window_length`` may be too large.
In general, you should choose a ``window_length`` that is small enough to
preserve the original data structure, but large enough to remove
"spikes" and high-frequency noise. Always inspect the results to ensure
that the filter is not removing important features.

.. GENERATED FROM PYTHON SOURCE LINES 217-228

Smoothing with a Savitzky-Golay filter
--------------------------------------
Here we use the :py:func:`movement.filtering.savgol_filter` function,
which is a wrapper around :py:func:`scipy.signal.savgol_filter`.
The Savitzky-Golay filter is a polynomial smoothing filter that can be
applied to time series data on a rolling window basis. A polynomial of
degree ``polyorder`` is fitted to the data in each window of length
``window_length``, and the value of the polynomial at the center of the
window is used as the output value.

Let's try it on the mouse dataset.

.. GENERATED FROM PYTHON SOURCE LINES 228-232

.. code-block:: Python


    ds_mouse_savgol = savgol_filter(ds_mouse, window_length=0.2, polyorder=2)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 4494/18485 (24.3%)
                    left_ear: 513/18485 (2.8%)
                    right_ear: 533/18485 (2.9%)
                    centre: 490/18485 (2.7%)
                    tail_base: 704/18485 (3.8%)
                    tail_end: 2496/18485 (13.5%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    snout: 5810/18485 (31.4%)
                    left_ear: 895/18485 (4.8%)
                    right_ear: 905/18485 (4.9%)
                    centre: 839/18485 (4.5%)
                    tail_base: 1186/18485 (6.4%)
                    tail_end: 3801/18485 (20.6%)




.. GENERATED FROM PYTHON SOURCE LINES 233-239

We see that the number of NaN values has increased after filtering. This is
for the same reason as with the median filter (in its default mode), i.e.
if there is at least one NaN value in the window, the output will be NaN.
Unlike the median filter, the Savitzky-Golay filter does not provide a
``min_periods`` parameter to control this behaviour. Let's visualise the
effects in the time and frequency domains.

.. GENERATED FROM PYTHON SOURCE LINES 239-243

.. code-block:: Python


    plot_raw_and_smooth_timeseries_and_psd(
        ds_mouse, ds_mouse_savgol, keypoint="snout", time_range=slice(0, 80)
    )



.. image-sg:: /examples/images/sphx_glr_smooth_004.png
   :alt: Time Domain, Frequency Domain
   :srcset: /examples/images/sphx_glr_smooth_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 244-246

Once again, the power of high-frequency components has been reduced, but more
missing values have been introduced.

.. GENERATED FROM PYTHON SOURCE LINES 248-249

Now let's take a look at the wasp dataset.

.. GENERATED FROM PYTHON SOURCE LINES 249-252

.. code-block:: Python


    ds_wasp_savgol = savgol_filter(ds_wasp, window_length=0.2, polyorder=2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    head: 0/1085 (0.0%)
                    stinger: 0/1085 (0.0%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    head: 0/1085 (0.0%)
                    stinger: 0/1085 (0.0%)




.. GENERATED FROM PYTHON SOURCE LINES 253-258

.. code-block:: Python

    plot_raw_and_smooth_timeseries_and_psd(
        ds_wasp,
        ds_wasp_savgol,
        keypoint="stinger",
    )



.. image-sg:: /examples/images/sphx_glr_smooth_005.png
   :alt: Time Domain, Frequency Domain
   :srcset: /examples/images/sphx_glr_smooth_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 259-267

This example shows two important limitations of the Savitzky-Golay filter.
First, the filter can introduce artefacts around sharp boundaries. For
example, focus on what happens around the sudden drop in position
during the final second. Second, the PSD appears to have large periodic
drops at certain frequencies. Both of these effects vary with the
choice of ``window_length`` and ``polyorder``. You can read more about these
and other limitations of the Savitzky-Golay filter in
`this paper <https://pubs.acs.org/doi/10.1021/acsmeasuresciau.1c00054>`_.

.. GENERATED FROM PYTHON SOURCE LINES 270-279

Combining multiple smoothing filters
------------------------------------
You can also combine multiple smoothing filters by applying them
sequentially. For example, we can first apply the median filter with a small
``window_length`` to remove "spikes" and then apply the Savitzky-Golay filter
with a larger ``window_length`` to further smooth the data.
Between the two filters, we can interpolate over small gaps to avoid the
excessive proliferation of NaN values. Let's try this on the mouse dataset.
First, let's apply the median filter.

.. GENERATED FROM PYTHON SOURCE LINES 279-282

.. code-block:: Python


    ds_mouse_medfilt = median_filter(ds_mouse, window_length=0.1, min_periods=2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 4494/18485 (24.3%)
                    left_ear: 513/18485 (2.8%)
                    right_ear: 533/18485 (2.9%)
                    centre: 490/18485 (2.7%)
                    tail_base: 704/18485 (3.8%)
                    tail_end: 2496/18485 (13.5%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    snout: 4455/18485 (24.1%)
                    left_ear: 487/18485 (2.6%)
                    right_ear: 507/18485 (2.7%)
                    centre: 465/18485 (2.5%)
                    tail_base: 673/18485 (3.6%)
                    tail_end: 2428/18485 (13.1%)




.. GENERATED FROM PYTHON SOURCE LINES 283-284

Next, let's linearly interpolate over gaps smaller than 1 second.

.. GENERATED FROM PYTHON SOURCE LINES 284-287

.. code-block:: Python


    ds_mouse_medfilt_interp = interpolate_over_time(ds_mouse_medfilt, max_gap=1)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 4455/18485 (24.1%)
                    left_ear: 487/18485 (2.6%)
                    right_ear: 507/18485 (2.7%)
                    centre: 465/18485 (2.5%)
                    tail_base: 673/18485 (3.6%)
                    tail_end: 2428/18485 (13.1%)

    Missing points (marked as NaN) in interpolated dataset:
            Individual: individual_0
                    snout: 3011/18485 (16.3%)
                    left_ear: 257/18485 (1.4%)
                    right_ear: 294/18485 (1.6%)
                    centre: 257/18485 (1.4%)
                    tail_base: 257/18485 (1.4%)
                    tail_end: 1191/18485 (6.4%)




.. GENERATED FROM PYTHON SOURCE LINES 288-289

Finally, let's apply the Savitzky-Golay filter.

.. GENERATED FROM PYTHON SOURCE LINES 289-294

.. code-block:: Python


    ds_mouse_medfilt_interp_savgol = savgol_filter(
        ds_mouse_medfilt_interp, window_length=0.4, polyorder=2
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Missing points (marked as NaN) in input dataset:
            Individual: individual_0
                    snout: 3011/18485 (16.3%)
                    left_ear: 257/18485 (1.4%)
                    right_ear: 294/18485 (1.6%)
                    centre: 257/18485 (1.4%)
                    tail_base: 257/18485 (1.4%)
                    tail_end: 1191/18485 (6.4%)

    Missing points (marked as NaN) in filtered dataset:
            Individual: individual_0
                    snout: 3520/18485 (19.0%)
                    left_ear: 306/18485 (1.7%)
                    right_ear: 354/18485 (1.9%)
                    centre: 306/18485 (1.7%)
                    tail_base: 306/18485 (1.7%)
                    tail_end: 1427/18485 (7.7%)




.. GENERATED FROM PYTHON SOURCE LINES 295-297

A record of all applied operations is stored in the dataset's ``log``
attribute. Let's inspect it to summarise what we've done.

.. GENERATED FROM PYTHON SOURCE LINES 297-301

.. code-block:: Python


    for entry in ds_mouse_medfilt_interp_savgol.log:
        print(entry)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    {'operation': 'median_filter', 'datetime': '2024-07-29 16:38:36.328097', 'window_length': 0.1, 'min_periods': 2}
    {'operation': 'interpolate_over_time', 'datetime': '2024-07-29 16:38:36.367864', 'max_gap': 1}
    {'operation': 'savgol_filter', 'datetime': '2024-07-29 16:38:36.385213', 'window_length': 0.4, 'polyorder': 2}




.. GENERATED FROM PYTHON SOURCE LINES 302-304

Now let's visualise the difference between the raw data and the final
smoothed result.

.. GENERATED FROM PYTHON SOURCE LINES 304-312

.. code-block:: Python


    plot_raw_and_smooth_timeseries_and_psd(
        ds_mouse,
        ds_mouse_medfilt_interp_savgol,
        keypoint="snout",
        time_range=slice(0, 80),
    )




.. image-sg:: /examples/images/sphx_glr_smooth_006.png
   :alt: Time Domain, Frequency Domain
   :srcset: /examples/images/sphx_glr_smooth_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 313-315

Feel free to play around with the parameters of the applied filters and to
also look at other keypoints and time ranges.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.613 seconds)


.. _sphx_glr_download_examples_smooth.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/neuroinformatics-unit/movement/gh-pages?filepath=notebooks/examples/smooth.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: smooth.ipynb <smooth.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: smooth.py <smooth.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: smooth.zip <smooth.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
